{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bahalla","text":"<p>This site is dedicated to documenting my learning journey across several domains:</p> <ul> <li>Software Engineering: Exploring design patterns, architecture, and best practices.</li> <li>Data Engineering: Notes on data pipelines, warehousing, and processing frameworks.</li> <li>Artificial Intelligence: Insights into machine learning, deep learning, and AI platforms.</li> <li>DevOps: Documenting CI/CD, infrastructure as code, and automation techniques.</li> </ul>"},{"location":"kafka/","title":"Apache Kafka","text":"<p>Apache Kafka is a distributed event-streaming platform used for high-performance data pipelines, streaming analytics, and event-driven applications.</p>"},{"location":"kafka/#what-iszookeepers-role-in-kafka","title":"What isZooKeeper\u2019s Role in Kafka ?","text":"<p>Overview</p> <p>ZooKeeper was traditionally used to manage the state of a Kafka cluster, including:</p> <ul> <li>Cluster membership  </li> <li>Leader elections  </li> </ul> <p>Since Kafka 4.x</p> <p>Kafka no longer requires ZooKeeper. The KRaft (Kafka Raft) mode fully replaces it.</p>"},{"location":"kafka/#what-is-kafka-kraft-mode","title":"What is kafka KRaft Mode ?","text":"<p>Definition</p> <p>KRaft (Kafka Raft) is Kafka\u2019s built-in consensus protocol that lets Kafka manage its own metadata without ZooKeeper.</p> Node Type Responsibilities Controller Maintains cluster metadata, leader election, configs Broker Handles client traffic and persists topic data"},{"location":"kafka/#how-kafka-guarantees-message-ordering","title":"How kafka guarantees message ordering ?","text":"<p>Guarantee</p> <p>Kafka guarantees message order only within a single partition.</p> <p>For example, if messages <code>M1</code> and <code>M2</code> are sent to partition <code>P0</code>, a consumer <code>C1</code> will always read <code>M1</code> before <code>M2</code>.</p> <p>Important</p> <p>Kafka does not guarantee order across different partitions.</p>"},{"location":"kubernetes/","title":"Kubernetes","text":"<p>Kubernetes (often called K8s) is an open-source platform for automating deployment, scaling, and management of containerized applications. It provides a powerful, declarative API so you can describe the desired state of your workloads and let the system maintain it.</p>"},{"location":"kubernetes/#overview","title":"Overview","text":"<ul> <li>Container Orchestration \u2013 schedules and runs containers across a cluster of machines.</li> <li>Declarative Configuration \u2013 you describe the desired state (e.g., \u201c3 replicas\u201d) and Kubernetes continuously works to match it.</li> <li>Self-Healing \u2013 automatically restarts or reschedules failed containers.</li> <li>Horizontal Scaling \u2013 add or remove pods seamlessly based on demand.</li> </ul>"},{"location":"kubernetes/#architecture","title":"Architecture","text":"<p>The diagram below shows the main components of a Kubernetes cluster:</p> <p></p> <p>Key Pieces</p>"},{"location":"kubernetes/#control-plane","title":"Control Plane","text":"<p>The control plane manages the entire cluster and keeps the system\u2019s desired state.</p> Component Role API Server Central management entrypoint; validates and processes requests. Scheduler Chooses which node should run a new pod. Controller Manager Ensures the cluster matches the declared state (replicas, endpoints, etc.). etcd Highly available key\u2013value store holding cluster configuration and state."},{"location":"kubernetes/#worker-nodes","title":"Worker Nodes","text":"<p>Worker nodes run your actual workloads (containers/pods).</p> Component Role Kubelet Agent on each node that talks to the API server and manages pods. Kube-Proxy Maintains networking rules and handles service discovery/load-balancing. Container Runtime Software (e.g., containerd, CRI-O) that runs the containers."}]}